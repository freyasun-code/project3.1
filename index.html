<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Project 3A: Image Warping and Mosaicing</title>
  <style>
    body {
      background-color: #D8C3DD;
      font-family: Arial, sans-serif;
      color: white;
      margin: 0;
      padding: 0;
    }
    nav {
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 20px;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    nav a {
      color: #ffddff;
      text-decoration: none;
      margin: 0 15px;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    .container {
      width: 90%;
      margin: auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-top: 20px;
    }
    .section {
      background: rgba(0,0,0,0.25);
      padding: 30px;
      margin: 40px 0;
      border-radius: 12px;
    }
    .section h2 {
      color: #ffddff;
      text-align: center;
    }
    img {
      max-width: 100%;
      border-radius: 8px;
    }
    .row {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .img-block {
      text-align: center;
    }
    .img-block p {
      margin-top: 8px;
      font-size: 16px;
      text-align: center;
    }
    p {
      text-align: left;
      max-width: 1000px;
      margin: auto;
      margin-bottom: 20px;
      font-size: 18px;
    }
  </style>
</head>

<body>
  <nav>
    <a href="#A1">A.1</a>
    <a href="#A2">A.2</a>
    <a href="#A3">A.3</a>
    <a href="#A4">A.4</a>
  </nav>

  <div class="container">
    <h1>Project 3A: Image Warping and Mosaicing</h1>
    <p style="text-align:center; font-style:italic;">Freya Sun</p>

```html
<!-- A.1 -->
<div class="section" id="A1">
  <h2>A.1: Shoot the Pictures</h2>
  <p>Here are my three sets of images.</p>

  <div class="row">
    <div class="img-block">
      <img src="tower-left.jpg" alt="tower left" width="350">
      <p>tower-left</p>
    </div>
    <div class="img-block">
      <img src="tower-right.jpg" alt="tower right" width="350">
      <p>tower-right</p>
    </div>
  </div>

  <div class="row">
    <div class="img-block">
      <img src="library-left.jpg" alt="library left" width="300">
      <p>library-left</p>
    </div>
    <div class="img-block">
      <img src="library-middle.jpg" alt="library middle" width="300">
      <p>library-middle</p>
    </div>
    <div class="img-block">
      <img src="library-right.jpg" alt="library right" width="300">
      <p>library-right</p>
    </div>
  </div>

  <div class="row">
    <div class="img-block">
      <img src="street-left.jpg" alt="street left" width="300">
      <p>street-left</p>
    </div>
    <div class="img-block">
      <img src="street-middle.jpg" alt="street middle" width="300">
      <p>street-middle</p>
    </div>
    <div class="img-block">
      <img src="street-right.jpg" alt="street right" width="300">
      <p>street-right</p>
    </div>
  </div>
</div>

<!-- A.2 -->
<div class="section" id="A2">
  <h2>A.2: Recovering the Homography</h2>

  <h3>computeH(im1_pts, im2_pts) function:</h3>

  <pre><code>def computeH(src_pts, dst_pts):
    assert src_pts.shape == dst_pts.shape and src_pts.shape[0] >= 4
    num_points = src_pts.shape[0]
    A = []
    b = []
    for i in range(num_points):
        x, y = src_pts[i, :]
        u, v = dst_pts[i, :]
        A.append([x, y, 1, 0, 0, 0, -u*x, -u*y])
        A.append([0, 0, 0, x, y, 1, -v*x, -v*y])
        b.append(u)
        b.append(v)
    A = np.array(A)
    b = np.array(b)
    h, _, _, _ = np.linalg.lstsq(A, b, rcond=None)
    H = np.append(h, 1).reshape(3, 3)
    return H
  </code></pre>

  <h3>Recovered Homography Matrix H:</h3>

  <pre><code>[[ 1.82  -0.05 -888.37]
 [ 0.36   1.50 -404.83]
 [ 0.00   0.00   1.00]]
  </code></pre>

  <h3>System of Equations:</h3>

  <p>
    To align one image to another, we want to find a <b>homography matrix</b> \( H \) that maps a point 
    \((x, y)\) in the first image to its corresponding point \((u, v)\) in the second image:
  </p>

  <p style="text-align:center;">
    \[
    \lambda 
    \begin{bmatrix}
    u \\ v \\ 1
    \end{bmatrix}
    =
    H
    \begin{bmatrix}
    x \\ y \\ 1
    \end{bmatrix},
    \]
  </p>

  <p>
    where \(\lambda\) is an arbitrary scale factor, and \(H\) has 8 degrees of freedom 
    (the ninth element is fixed to 1).
  </p>

  <h4>Setting up the Linear System</h4>
  <p>
    Expanding the equations gives:
  </p>

  <p style="text-align:center;">
    \[
    u = \frac{h_1x + h_2y + h_3}{h_7x + h_8y + 1}, \quad
    v = \frac{h_4x + h_5y + h_6}{h_7x + h_8y + 1}.
    \]
  </p>

  <p>
    Multiplying both sides by the denominator and rearranging terms produces two linear equations per point:
  </p>

  <p style="text-align:center;">
    \[
    \begin{cases}
    h_1x + h_2y + h_3 - u(h_7x + h_8y) = u, \\
    h_4x + h_5y + h_6 - v(h_7x + h_8y) = v.
    \end{cases}
    \]
  </p>

  <p>
    For each correspondence pair \((x, y) \leftrightarrow (u, v)\), we can write these as two rows in a linear system:
  </p>

  <p style="text-align:center;">
    \[
    \begin{bmatrix}
    x & y & 1 & 0 & 0 & 0 & -ux & -uy \\
    0 & 0 & 0 & x & y & 1 & -vx & -vy
    \end{bmatrix}
    \begin{bmatrix}
    h_1 \\ h_2 \\ h_3 \\ h_4 \\ h_5 \\ h_6 \\ h_7 \\ h_8
    \end{bmatrix}
    =
    \begin{bmatrix}
    u \\ v
    \end{bmatrix}.
    \]
  </p>

  <h4>Solving the System</h4>
  <p>
    Each point pair provides two equations, so we need at least <b>four correspondences</b> (eight equations) 
    to solve for the eight unknowns in \(h\). When more than four points are available, the system becomes 
    overdetermined, and we can find the best-fit solution using <b>least squares</b>:
  </p>

  <p style="text-align:center;">
    \[
    h = \operatorname*{argmin}_h \| A h - b \|^2.
    \]
  </p>

  <p>
    Finally, the 3×3 homography matrix is obtained as:
  </p>

  <p style="text-align:center;">
    \[
    H =
    \begin{bmatrix}
    h_1 & h_2 & h_3 \\
    h_4 & h_5 & h_6 \\
    h_7 & h_8 & 1
    \end{bmatrix}.
    \]
  </p>

  <p style="font-style:italic; text-align:center;">
    This matrix captures the projective transformation between two images and allows us 
    to warp one image onto another for rectification or mosaicing.
  </p>

  <h3>Correspondences Visualized on the Images:</h3>

  <div class="row">
    <div class="img-block">
      <img src="im1_points.jpg" alt="image 1 with correspondences" width="400">
      <p>Image 1 (Left)</p>
    </div>
    <div class="img-block">
      <img src="im2_points.jpg" alt="image 2 with correspondences" width="400">
      <p>Image 2 (Right)</p>
    </div>
  </div>
</div>


<!-- A.3 -->
<div class="section" id="A3">
  <h2>A.3: Warp the Images</h2>
  <p>
    Function definitions:
    <br><code>imwarped_nn = warpImageNearestNeighbor(im, H)</code><br>
    <code>imwarped_bil = warpImageBilinear(im, H)</code>
  </p>
  <p>Inverse warping is used to avoid holes in the output image.</p>
  <p>
    The Nearest Neighbor Interpolation took <b>1.459 seconds</b>, while the Bilinear Interpolation took <b>2.756 seconds</b>.
  </p>

  <div class="row">
    <div class="img-block">
      <img src="macbook.jpg" alt="original macbook" width="300">
      <p>Original Image</p>
    </div>
    <div class="img-block">
      <img src="macbook_nearest_neighbor.jpg" alt="nearest neighbor" width="300">
      <p>Nearest Neighbor Result</p>
    </div>
    <div class="img-block">
      <img src="macbook_bilinear.jpg" alt="bilinear" width="300">
      <p>Bilinear Result</p>
    </div>
  </div>

  <div class="row">
    <div class="img-block">
      <img src="book.jpg" alt="original book" width="300">
      <p>Original Image</p>
    </div>
    <div class="img-block">
      <img src="book_nearest_neighbor.jpg" alt="book nearest neighbor" width="300">
      <p>Nearest Neighbor Result</p>
    </div>
    <div class="img-block">
      <img src="book_bilinear.jpg" alt="book bilinear" width="300">
      <p>Bilinear Result</p>
    </div>
  </div>
</div>

```html
<!-- A.4 -->
<div class="section" id="A4">
  <h2>A.4: Blend the Images into a Mosaic</h2>

  <p>
    One suggestion is to set it to 1 at the center of each (unwarped) image and make it fall off linearly until it hits 0 at the edges (or use the distance transform <code>bwdist</code>). However, this can produce some strange wedge-like artifacts. You can try minimizing these by using a more sophisticated blending technique, such as a Laplacian pyramid. If your only problem is “ghosting” of high-frequency terms, then a 2-level pyramid should be enough.
  </p>

  <p>
    Since only 8 pairs of correspondence points were selected, and I could not perfectly keep the phone centered while shooting, the resulting mosaics are slightly misaligned and show some ghosting artifacts.
  </p>

  <div class="row">
    <div class="img-block">
      <img src="tower-mosaic_weighted.jpg" alt="tower weighted mosaic" width="400">
      <p>Weighted Averaging Mosaic (Tower)</p>
    </div>
    <div class="img-block">
      <img src="tower-mosaic_pyramid.jpg" alt="tower pyramid mosaic" width="400">
      <p>Laplacian Pyramid Mosaic (Tower)</p>
    </div>
  </div>

  <div class="row">
    <div class="img-block">
      <img src="library-mosaic_weighted.jpg" alt="library weighted mosaic" width="400">
      <p>Weighted Averaging Mosaic (Library)</p>
    </div>
    <div class="img-block">
      <img src="library-mosaic_pyramid.jpg" alt="library pyramid mosaic" width="400">
      <p>Laplacian Pyramid Mosaic (Library)</p>
    </div>
  </div>

  <div class="row">
    <div class="img-block">
      <img src="street-mosaic_weighted.jpg" alt="street weighted mosaic" width="400">
      <p>Weighted Averaging Mosaic (Street)</p>
    </div>
    <div class="img-block">
      <img src="street-mosaic_pyramid.jpg" alt="street pyramid mosaic" width="400">
      <p>Laplacian Pyramid Mosaic (Street)</p>
    </div>
  </div>
</div>


  </div>
</body>
</html>

